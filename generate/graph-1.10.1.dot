digraph {
  rankdir=LR;
  dpi=55;
  nodesep=0.10;
  ranksep=1.2;
  mclimit=2500.0;
  node[ fontname=Helvetica shape=box ];

  subgraph cluster_legend {
    label="Legend"
    fontname="Helvetica Bold"
    fontsize=19
    bgcolor="#dddddd"
    "Clojure class" [ shape=oval fillcolor="#ffffff" style=filled ];
    "Clojure Interface" [ shape=octagon fillcolor="#ffffff" style=filled ];
    "Java class" [ shape=box fillcolor="#ffffff" style=filled ];
    "Java Interface" [ shape=parallelogram fillcolor="#ffffff" style=filled ];
    
    badges [
      shape=record
      style=filled
      fillcolor="#ffffff"
      label="{{D|M|W|T|1|H|Z|R|N|=}|{IType|IMeta|IObj|Iterable|Counted|IHashEq|Serializable|Reversible|Named|Comparable}|{type created by deftype|meta|with-meta||counted?, count is O(1)|hash||reversible?, rseq is O(1)||}}"
    ]
    java_package_abbreviations [
      shape=record
      style=filled
      fillcolor="#ffffff"
      label="{{Abbrev.|c.c|j.l|j.u.c|j.u}|{Java Package|clojure.core|java.lang|java.util.concurrent|java.util}}"
    ]
  }
  "class clojure.lang.AFn" [ label="AFn" color="#76d700" shape="oval"];
  "class clojure.lang.AFn" -> "interface clojure.lang.IFn" [ color="#76d700" ];
  "class clojure.lang.AFunction" [ label="AFunction\n[MWZ]" color="#d70000" shape="oval"];
  "class clojure.lang.AFunction" -> "class clojure.lang.AFn" [ color="#d70000" ];
  "class clojure.lang.AFunction" -> "interface java.util.Comparator" [ color="#d70000" ];
  "class clojure.lang.AFunction" -> "interface clojure.lang.Fn" [ color="#d70000" ];
  "class clojure.lang.AMapEntry" [ label="AMapEntry\n[T1HZR=]" color="#5a00d7" shape="oval"];
  "class clojure.lang.AMapEntry" -> "class clojure.lang.APersistentVector" [ color="#5a00d7" ];
  "class clojure.lang.AMapEntry" -> "interface clojure.lang.IMapEntry" [ color="#5a00d7" ];
  "class clojure.lang.APersistentMap" [ label="APersistentMap\n[T1HZ]" color="#b300d7" shape="oval"];
  "class clojure.lang.APersistentMap" -> "class clojure.lang.AFn" [ color="#b300d7" ];
  "class clojure.lang.APersistentMap" -> "interface clojure.lang.IPersistentMap" [ color="#b300d7" ];
  "class clojure.lang.APersistentMap" -> "interface java.util.Map" [ color="#b300d7" ];
  "class clojure.lang.APersistentMap" -> "interface clojure.lang.MapEquivalence" [ color="#b300d7" ];
  "class clojure.lang.APersistentSet" [ label="APersistentSet\n[T1HZ]" color="#5a00d7" shape="oval"];
  "class clojure.lang.APersistentSet" -> "class clojure.lang.AFn" [ color="#5a00d7" ];
  "class clojure.lang.APersistentSet" -> "interface clojure.lang.IPersistentSet" [ color="#5a00d7" ];
  "class clojure.lang.APersistentSet" -> "interface java.util.Collection" [ color="#5a00d7" ];
  "class clojure.lang.APersistentSet" -> "interface java.util.Set" [ color="#5a00d7" ];
  "class clojure.lang.APersistentVector" [ label="APersistentVector\n[T1HZR=]" color="#b300d7" shape="oval"];
  "class clojure.lang.APersistentVector" -> "class clojure.lang.AFn" [ color="#b300d7" ];
  "class clojure.lang.APersistentVector" -> "interface clojure.lang.IPersistentVector" [ color="#b300d7" ];
  "class clojure.lang.APersistentVector" -> "interface java.util.List" [ color="#b300d7" ];
  "class clojure.lang.APersistentVector" -> "interface java.util.RandomAccess" [ color="#b300d7" ];
  "class clojure.lang.ARef" [ label="ARef\n[M]" color="#00d0d7" shape="oval"];
  "class clojure.lang.ARef" -> "class clojure.lang.AReference" [ color="#00d0d7" ];
  "class clojure.lang.ARef" -> "interface clojure.lang.IRef" [ color="#00d0d7" ];
  "class clojure.lang.AReference" [ label="AReference\n[M]" color="#d70000" shape="oval"];
  "class clojure.lang.AReference" -> "interface clojure.lang.IReference" [ color="#d70000" ];
  "class clojure.lang.ASeq" [ label="ASeq\n[MWTHZ]" color="#00d0d7" shape="oval"];
  "class clojure.lang.ASeq" -> "class clojure.lang.Obj" [ color="#00d0d7" ];
  "class clojure.lang.ASeq" -> "interface clojure.lang.ISeq" [ color="#00d0d7" ];
  "class clojure.lang.ASeq" -> "interface clojure.lang.Sequential" [ color="#00d0d7" ];
  "class clojure.lang.ASeq" -> "interface java.util.List" [ color="#00d0d7" ];
  "class clojure.lang.ATransientMap" [ label="ATransientMap\n[1]" color="#d78100" shape="oval"];
  "class clojure.lang.ATransientMap" -> "class clojure.lang.AFn" [ color="#d78100" ];
  "class clojure.lang.ATransientMap" -> "interface clojure.lang.ITransientMap" [ color="#d78100" ];
  "class clojure.lang.ATransientMap" -> "interface clojure.lang.ITransientAssociative2" [ color="#d78100" ];
  "class clojure.lang.ATransientSet" [ label="ATransientSet\n[1]" color="#76d700" shape="oval"];
  "class clojure.lang.ATransientSet" -> "class clojure.lang.AFn" [ color="#76d700" ];
  "class clojure.lang.ATransientSet" -> "interface clojure.lang.ITransientSet" [ color="#76d700" ];
  "class clojure.lang.Agent" [ label="Agent\n[M]" color="#00d764" shape="oval"];
  "class clojure.lang.Agent" -> "class clojure.lang.ARef" [ color="#00d764" ];
  "interface java.lang.annotation.Annotation" [ label="j.l.annotation.Annotation" color="#d70000" shape="parallelogram"];
  "class clojure.core.ArrayChunk" [ label="c.c.ArrayChunk\n[D1]" color="#0061d7" shape="oval"];
  "class clojure.core.ArrayChunk" -> "interface clojure.lang.IChunk" [ color="#0061d7" ];
  "class clojure.core.ArrayChunk" -> "interface clojure.lang.Indexed" [ color="#0061d7" ];
  "class clojure.lang.ArrayChunk" [ label="ArrayChunk\n[1Z]" color="#76d700" shape="oval"];
  "class clojure.lang.ArrayChunk" -> "interface clojure.lang.IChunk" [ color="#76d700" ];
  "class clojure.lang.ArrayIter" [ label="ArrayIter" color="#00d764" shape="oval"];
  "class clojure.lang.ArrayIter" -> "interface java.util.Iterator" [ color="#00d764" ];
  "class clojure.lang.ArraySeq" [ label="ArraySeq\n[MWT1HZ]" color="#5a00d7" shape="oval"];
  "class clojure.lang.ArraySeq" -> "class clojure.lang.ASeq" [ color="#5a00d7" ];
  "class clojure.lang.ArraySeq" -> "interface clojure.lang.IndexedSeq" [ color="#5a00d7" ];
  "class clojure.lang.ArraySeq" -> "interface clojure.lang.IReduce" [ color="#5a00d7" ];
  "class clojure.reflect.AsmReflector" [ label="clojure.reflect.AsmReflector\n[D]" color="#d70000" shape="oval"];
  "class clojure.reflect.AsmReflector" -> "interface clojure.reflect.Reflector" [ color="#d70000" ];
  "interface clojure.lang.Associative" [ label="Associative\nassociative?" color="#76d700" shape="octagon"];
  "interface clojure.lang.Associative" -> "interface clojure.lang.IPersistentCollection" [ color="#76d700" ];
  "interface clojure.lang.Associative" -> "interface clojure.lang.ILookup" [ color="#76d700" ];
  "class clojure.lang.Atom" [ label="Atom\n[M]" color="#b300d7" shape="oval"];
  "class clojure.lang.Atom" -> "class clojure.lang.ARef" [ color="#b300d7" ];
  "class clojure.lang.Atom" -> "interface clojure.lang.IAtom2" [ color="#b300d7" ];
  "class clojure.lang.BigInt" [ label="BigInt\n[HZ]" color="#d70000" shape="oval"];
  "interface java.util.concurrent.Callable" [ label="j.u.c.Callable" color="#00d764" shape="parallelogram"];
  "class clojure.core.reducers.Cat" [ label="c.c.reducers.Cat\n[D1]" color="#76d700" shape="oval"];
  "class clojure.core.reducers.Cat" -> "interface clojure.core.reducers.CollFold" [ color="#76d700" ];
  "class clojure.core.reducers.Cat" -> "interface clojure.lang.Seqable" [ color="#76d700" ];
  "class clojure.core.reducers.Cat" -> "interface clojure.core.protocols.CollReduce" [ color="#76d700" ];
  "class clojure.lang.ChunkBuffer" [ label="ChunkBuffer\n[1]" color="#b300d7" shape="oval"];
  "class clojure.lang.ChunkedCons" [ label="ChunkedCons\n[MWTHZ]" color="#5a00d7" shape="oval"];
  "class clojure.lang.ChunkedCons" -> "class clojure.lang.ASeq" [ color="#5a00d7" ];
  "class clojure.lang.ChunkedCons" -> "interface clojure.lang.IChunkedSeq" [ color="#5a00d7" ];
  "interface clojure.core.reducers.CollFold" [ label="c.c.reducers.CollFold" color="#00d0d7" shape="octagon"];
  "interface clojure.core.protocols.CollReduce" [ label="c.c.protocols.CollReduce" color="#0061d7" shape="octagon"];
  "interface java.util.Collection" [ label="j.u.Collection\n[T]" color="#00d764" shape="parallelogram"];
  "interface java.util.Comparator" [ label="j.u.Comparator" color="#00d0d7" shape="parallelogram"];
  "interface java.util.concurrent.ConcurrentMap" [ label="j.u.c.ConcurrentMap" color="#0061d7" shape="parallelogram"];
  "interface java.util.concurrent.ConcurrentMap" -> "interface java.util.Map" [ color="#0061d7" ];
  "class clojure.lang.Cons" [ label="Cons\n[MWTHZ]" color="#76d700" shape="oval"];
  "class clojure.lang.Cons" -> "class clojure.lang.ASeq" [ color="#76d700" ];
  "class clojure.lang.Cycle" [ label="Cycle\n[MWTHZ]" color="#d78100" shape="oval"];
  "class clojure.lang.Cycle" -> "class clojure.lang.ASeq" [ color="#d78100" ];
  "class clojure.lang.Cycle" -> "interface clojure.lang.IReduce" [ color="#d78100" ];
  "class clojure.lang.Cycle" -> "interface clojure.lang.IPending" [ color="#d78100" ];
  "class clojure.lang.Delay" [ label="Delay\ndelay?" color="#5a00d7" shape="oval"];
  "class clojure.lang.Delay" -> "interface clojure.lang.IDeref" [ color="#5a00d7" ];
  "class clojure.lang.Delay" -> "interface clojure.lang.IPending" [ color="#5a00d7" ];
  "class clojure.core.Eduction" [ label="c.c.Eduction\n[DT]" color="#00d764" shape="oval"];
  "class clojure.core.Eduction" -> "interface clojure.lang.IReduceInit" [ color="#00d764" ];
  "class clojure.core.Eduction" -> "interface clojure.lang.Sequential" [ color="#00d764" ];
  "interface java.util.Map$Entry" [ label="j.u.Map$Entry" color="#d7009e" shape="parallelogram"];
  "interface java.util.Enumeration" [ label="j.u.Enumeration" color="#5a00d7" shape="parallelogram"];
  "class clojure.lang.EnumerationSeq" [ label="EnumerationSeq\n[MWTHZ]" color="#00d0d7" shape="oval"];
  "class clojure.lang.EnumerationSeq" -> "class clojure.lang.ASeq" [ color="#00d0d7" ];
  "class clojure.lang.ExceptionInfo" [ label="ExceptionInfo\n[Z]" color="#5a00d7" shape="oval"];
  "class clojure.lang.ExceptionInfo" -> "interface clojure.lang.IExceptionInfo" [ color="#5a00d7" ];
  "interface clojure.lang.Fn" [ label="Fn\nfn?" color="#0061d7" shape="octagon"];
  "class clojure.lang.FnLoaderThunk" [ label="FnLoaderThunk\n[MWZ]" color="#76d700" shape="oval"];
  "class clojure.lang.FnLoaderThunk" -> "class clojure.lang.RestFn" [ color="#76d700" ];
  "interface java.util.concurrent.Future" [ label="j.u.c.Future" color="#5a00d7" shape="parallelogram"];
  "interface clojure.lang.IAtom" [ label="IAtom" color="#b300d7" shape="octagon"];
  "interface clojure.lang.IAtom2" [ label="IAtom2" color="#0061d7" shape="octagon"];
  "interface clojure.lang.IAtom2" -> "interface clojure.lang.IAtom" [ color="#0061d7" ];
  "interface clojure.lang.IBlockingDeref" [ label="IBlockingDeref" color="#5a00d7" shape="octagon"];
  "interface clojure.lang.IChunk" [ label="IChunk\n[1]" color="#0061d7" shape="octagon"];
  "interface clojure.lang.IChunk" -> "interface clojure.lang.Indexed" [ color="#0061d7" ];
  "interface clojure.lang.IChunkedSeq" [ label="IChunkedSeq\nchunked-seq?" color="#d70000" shape="octagon"];
  "interface clojure.lang.IChunkedSeq" -> "interface clojure.lang.ISeq" [ color="#d70000" ];
  "interface clojure.lang.IChunkedSeq" -> "interface clojure.lang.Sequential" [ color="#d70000" ];
  "interface clojure.lang.IDeref" [ label="IDeref" color="#00d764" shape="octagon"];
  "interface clojure.lang.IEditableCollection" [ label="IEditableCollection" color="#76d700" shape="octagon"];
  "interface clojure.lang.IExceptionInfo" [ label="IExceptionInfo" color="#d70000" shape="octagon"];
  "interface clojure.lang.IFn" [ label="IFn\nifn?" color="#0061d7" shape="octagon"];
  "interface clojure.lang.IFn" -> "interface java.util.concurrent.Callable" [ color="#0061d7" ];
  "interface clojure.lang.IFn" -> "interface java.lang.Runnable" [ color="#0061d7" ];
  "interface clojure.lang.IKVReduce" [ label="IKVReduce" color="#5a00d7" shape="octagon"];
  "interface clojure.lang.ILookup" [ label="ILookup" color="#00d764" shape="octagon"];
  "interface clojure.lang.ILookupSite" [ label="ILookupSite" color="#00d764" shape="octagon"];
  "interface clojure.lang.ILookupThunk" [ label="ILookupThunk" color="#00d0d7" shape="octagon"];
  "interface clojure.lang.IMapEntry" [ label="IMapEntry" color="#00d0d7" shape="octagon"];
  "interface clojure.lang.IMapEntry" -> "interface java.util.Map$Entry" [ color="#00d0d7" ];
  "interface clojure.lang.IMapIterable" [ label="IMapIterable" color="#00d0d7" shape="octagon"];
  "interface clojure.lang.IPending" [ label="IPending" color="#d70000" shape="octagon"];
  "interface clojure.lang.IPersistentCollection" [ label="IPersistentCollection\ncoll?" color="#d7009e" shape="octagon"];
  "interface clojure.lang.IPersistentCollection" -> "interface clojure.lang.Seqable" [ color="#d7009e" ];
  "interface clojure.lang.IPersistentList" [ label="IPersistentList\nlist?" color="#5a00d7" shape="octagon"];
  "interface clojure.lang.IPersistentList" -> "interface clojure.lang.Sequential" [ color="#5a00d7" ];
  "interface clojure.lang.IPersistentList" -> "interface clojure.lang.IPersistentStack" [ color="#5a00d7" ];
  "interface clojure.lang.IPersistentMap" [ label="IPersistentMap\nmap?\n[T1]" color="#d70000" shape="octagon"];
  "interface clojure.lang.IPersistentMap" -> "interface clojure.lang.Associative" [ color="#d70000" ];
  "interface clojure.lang.IPersistentSet" [ label="IPersistentSet\nset?\n[1]" color="#d7009e" shape="octagon"];
  "interface clojure.lang.IPersistentSet" -> "interface clojure.lang.IPersistentCollection" [ color="#d7009e" ];
  "interface clojure.lang.IPersistentStack" [ label="IPersistentStack" color="#00d764" shape="octagon"];
  "interface clojure.lang.IPersistentStack" -> "interface clojure.lang.IPersistentCollection" [ color="#00d764" ];
  "interface clojure.lang.IPersistentVector" [ label="IPersistentVector\nvector?\n[1R]" color="#d7009e" shape="octagon"];
  "interface clojure.lang.IPersistentVector" -> "interface clojure.lang.Associative" [ color="#d7009e" ];
  "interface clojure.lang.IPersistentVector" -> "interface clojure.lang.Sequential" [ color="#d7009e" ];
  "interface clojure.lang.IPersistentVector" -> "interface clojure.lang.IPersistentStack" [ color="#d7009e" ];
  "interface clojure.lang.IPersistentVector" -> "interface clojure.lang.Indexed" [ color="#d7009e" ];
  "interface clojure.lang.IReduce" [ label="IReduce" color="#d7009e" shape="octagon"];
  "interface clojure.lang.IReduce" -> "interface clojure.lang.IReduceInit" [ color="#d7009e" ];
  "interface clojure.lang.IReduceInit" [ label="IReduceInit" color="#00d764" shape="octagon"];
  "interface clojure.lang.IRef" [ label="IRef" color="#b300d7" shape="octagon"];
  "interface clojure.lang.IRef" -> "interface clojure.lang.IDeref" [ color="#b300d7" ];
  "interface clojure.lang.IReference" [ label="IReference\n[M]" color="#d78100" shape="octagon"];
  "interface clojure.lang.ISeq" [ label="ISeq\nseq?" color="#b300d7" shape="octagon"];
  "interface clojure.lang.ISeq" -> "interface clojure.lang.IPersistentCollection" [ color="#b300d7" ];
  "interface clojure.lang.ITransientAssociative" [ label="ITransientAssociative" color="#b300d7" shape="octagon"];
  "interface clojure.lang.ITransientAssociative" -> "interface clojure.lang.ITransientCollection" [ color="#b300d7" ];
  "interface clojure.lang.ITransientAssociative" -> "interface clojure.lang.ILookup" [ color="#b300d7" ];
  "interface clojure.lang.ITransientAssociative2" [ label="ITransientAssociative2" color="#d78100" shape="octagon"];
  "interface clojure.lang.ITransientAssociative2" -> "interface clojure.lang.ITransientAssociative" [ color="#d78100" ];
  "interface clojure.lang.ITransientCollection" [ label="ITransientCollection" color="#b300d7" shape="octagon"];
  "interface clojure.lang.ITransientMap" [ label="ITransientMap\n[1]" color="#00d0d7" shape="octagon"];
  "interface clojure.lang.ITransientMap" -> "interface clojure.lang.ITransientAssociative" [ color="#00d0d7" ];
  "interface clojure.lang.ITransientSet" [ label="ITransientSet\n[1]" color="#00d764" shape="octagon"];
  "interface clojure.lang.ITransientSet" -> "interface clojure.lang.ITransientCollection" [ color="#00d764" ];
  "interface clojure.lang.ITransientVector" [ label="ITransientVector\n[1]" color="#d7009e" shape="octagon"];
  "interface clojure.lang.ITransientVector" -> "interface clojure.lang.ITransientAssociative" [ color="#d7009e" ];
  "interface clojure.lang.ITransientVector" -> "interface clojure.lang.Indexed" [ color="#d7009e" ];
  "interface clojure.core.IVecImpl" [ label="c.c.IVecImpl" color="#d7009e" shape="octagon"];
  "interface clojure.lang.Indexed" [ label="Indexed\nindexed?\n[1]" color="#00d0d7" shape="octagon"];
  "interface clojure.lang.IndexedSeq" [ label="IndexedSeq\n[1]" color="#0061d7" shape="octagon"];
  "interface clojure.lang.IndexedSeq" -> "interface clojure.lang.ISeq" [ color="#0061d7" ];
  "interface clojure.lang.IndexedSeq" -> "interface clojure.lang.Sequential" [ color="#0061d7" ];
  "interface clojure.core.protocols.InternalReduce" [ label="c.c.protocols.InternalReduce" color="#d78100" shape="octagon"];
  "interface java.lang.reflect.InvocationHandler" [ label="j.l.reflect.InvocationHandler" color="#b300d7" shape="parallelogram"];
  "class clojure.lang.Iterate" [ label="Iterate\n[MWTHZ]" color="#d78100" shape="oval"];
  "class clojure.lang.Iterate" -> "class clojure.lang.ASeq" [ color="#d78100" ];
  "class clojure.lang.Iterate" -> "interface clojure.lang.IReduce" [ color="#d78100" ];
  "class clojure.lang.Iterate" -> "interface clojure.lang.IPending" [ color="#d78100" ];
  "interface java.util.Iterator" [ label="j.u.Iterator" color="#5a00d7" shape="parallelogram"];
  "class clojure.lang.IteratorSeq" [ label="IteratorSeq\n[MWTHZ]" color="#0061d7" shape="oval"];
  "class clojure.lang.IteratorSeq" -> "class clojure.lang.ASeq" [ color="#0061d7" ];
  "class clojure.reflect.JavaReflector" [ label="clojure.reflect.JavaReflector\n[D]" color="#5a00d7" shape="oval"];
  "class clojure.reflect.JavaReflector" -> "interface clojure.reflect.Reflector" [ color="#5a00d7" ];
  "class clojure.lang.Keyword" [ label="Keyword\nkeyword?\n[HZN=]" color="#76d700" shape="oval"];
  "class clojure.lang.Keyword" -> "interface clojure.lang.IFn" [ color="#76d700" ];
  "class clojure.lang.KeywordLookupSite" [ label="KeywordLookupSite" color="#d70000" shape="oval"];
  "class clojure.lang.KeywordLookupSite" -> "interface clojure.lang.ILookupSite" [ color="#d70000" ];
  "class clojure.lang.KeywordLookupSite" -> "interface clojure.lang.ILookupThunk" [ color="#d70000" ];
  "class clojure.lang.LazySeq" [ label="LazySeq\n[MWTHZ]" color="#d78100" shape="oval"];
  "class clojure.lang.LazySeq" -> "class clojure.lang.Obj" [ color="#d78100" ];
  "class clojure.lang.LazySeq" -> "interface clojure.lang.ISeq" [ color="#d78100" ];
  "class clojure.lang.LazySeq" -> "interface clojure.lang.Sequential" [ color="#d78100" ];
  "class clojure.lang.LazySeq" -> "interface java.util.List" [ color="#d78100" ];
  "class clojure.lang.LazySeq" -> "interface clojure.lang.IPending" [ color="#d78100" ];
  "interface java.util.List" [ label="j.u.List\n[T]" color="#00d764" shape="parallelogram"];
  "interface java.util.List" -> "interface java.util.Collection" [ color="#00d764" ];
  "class clojure.lang.LongRange" [ label="LongRange\n[MWT1HZ]" color="#d78100" shape="oval"];
  "class clojure.lang.LongRange" -> "class clojure.lang.ASeq" [ color="#d78100" ];
  "class clojure.lang.LongRange" -> "interface clojure.lang.IChunkedSeq" [ color="#d78100" ];
  "class clojure.lang.LongRange" -> "interface clojure.lang.IReduce" [ color="#d78100" ];
  "interface java.util.Map" [ label="j.u.Map" color="#00d764" shape="parallelogram"];
  "class clojure.lang.MapEntry" [ label="MapEntry\n[T1HZR=]" color="#0061d7" shape="oval"];
  "class clojure.lang.MapEntry" -> "class clojure.lang.AMapEntry" [ color="#0061d7" ];
  "interface clojure.lang.MapEquivalence" [ label="MapEquivalence" color="#d78100" shape="octagon"];
  "class clojure.lang.MultiFn" [ label="MultiFn" color="#76d700" shape="oval"];
  "class clojure.lang.MultiFn" -> "class clojure.lang.AFn" [ color="#76d700" ];
  "class clojure.lang.Namespace" [ label="Namespace\n[MZ]" color="#76d700" shape="oval"];
  "class clojure.lang.Namespace" -> "class clojure.lang.AReference" [ color="#76d700" ];
  "class clojure.lang.Obj" [ label="Obj\n[MWZ]" color="#00d764" shape="oval"];
  "class clojure.lang.PersistentArrayMap" [ label="PersistentArrayMap\n[MWT1HZ]" color="#5a00d7" shape="oval"];
  "class clojure.lang.PersistentArrayMap" -> "class clojure.lang.APersistentMap" [ color="#5a00d7" ];
  "class clojure.lang.PersistentArrayMap" -> "interface clojure.lang.IEditableCollection" [ color="#5a00d7" ];
  "class clojure.lang.PersistentArrayMap" -> "interface clojure.lang.IMapIterable" [ color="#5a00d7" ];
  "class clojure.lang.PersistentArrayMap" -> "interface clojure.lang.IKVReduce" [ color="#5a00d7" ];
  "class clojure.lang.PersistentHashMap" [ label="PersistentHashMap\n[MWT1HZ]" color="#0061d7" shape="oval"];
  "class clojure.lang.PersistentHashMap" -> "class clojure.lang.APersistentMap" [ color="#0061d7" ];
  "class clojure.lang.PersistentHashMap" -> "interface clojure.lang.IEditableCollection" [ color="#0061d7" ];
  "class clojure.lang.PersistentHashMap" -> "interface clojure.lang.IMapIterable" [ color="#0061d7" ];
  "class clojure.lang.PersistentHashMap" -> "interface clojure.lang.IKVReduce" [ color="#0061d7" ];
  "class clojure.lang.PersistentHashSet" [ label="PersistentHashSet\n[MWT1HZ]" color="#5a00d7" shape="oval"];
  "class clojure.lang.PersistentHashSet" -> "class clojure.lang.APersistentSet" [ color="#5a00d7" ];
  "class clojure.lang.PersistentHashSet" -> "interface clojure.lang.IEditableCollection" [ color="#5a00d7" ];
  "class clojure.lang.PersistentList" [ label="PersistentList\n[MWT1HZ]" color="#76d700" shape="oval"];
  "class clojure.lang.PersistentList" -> "class clojure.lang.ASeq" [ color="#76d700" ];
  "class clojure.lang.PersistentList" -> "interface clojure.lang.IPersistentList" [ color="#76d700" ];
  "class clojure.lang.PersistentList" -> "interface clojure.lang.IReduce" [ color="#76d700" ];
  "class clojure.lang.PersistentList" -> "interface java.util.List" [ color="#76d700" ];
  "class clojure.lang.PersistentQueue" [ label="PersistentQueue\n[MWT1HZ]" color="#0061d7" shape="oval"];
  "class clojure.lang.PersistentQueue" -> "class clojure.lang.Obj" [ color="#0061d7" ];
  "class clojure.lang.PersistentQueue" -> "interface clojure.lang.IPersistentList" [ color="#0061d7" ];
  "class clojure.lang.PersistentQueue" -> "interface java.util.Collection" [ color="#0061d7" ];
  "class clojure.lang.PersistentStructMap" [ label="PersistentStructMap\n[MWT1HZ]" color="#00d0d7" shape="oval"];
  "class clojure.lang.PersistentStructMap" -> "class clojure.lang.APersistentMap" [ color="#00d0d7" ];
  "class clojure.lang.PersistentTreeMap" [ label="PersistentTreeMap\n[MWT1HZR]" color="#d78100" shape="oval"];
  "class clojure.lang.PersistentTreeMap" -> "class clojure.lang.APersistentMap" [ color="#d78100" ];
  "class clojure.lang.PersistentTreeMap" -> "interface clojure.lang.Sorted" [ color="#d78100" ];
  "class clojure.lang.PersistentTreeMap" -> "interface clojure.lang.IKVReduce" [ color="#d78100" ];
  "class clojure.lang.PersistentTreeSet" [ label="PersistentTreeSet\n[MWT1HZR]" color="#d70000" shape="oval"];
  "class clojure.lang.PersistentTreeSet" -> "class clojure.lang.APersistentSet" [ color="#d70000" ];
  "class clojure.lang.PersistentTreeSet" -> "interface clojure.lang.Sorted" [ color="#d70000" ];
  "class clojure.lang.PersistentVector" [ label="PersistentVector\n[MWT1HZR=]" color="#d78100" shape="oval"];
  "class clojure.lang.PersistentVector" -> "class clojure.lang.APersistentVector" [ color="#d78100" ];
  "class clojure.lang.PersistentVector" -> "interface clojure.lang.IEditableCollection" [ color="#d78100" ];
  "class clojure.lang.PersistentVector" -> "interface clojure.lang.IReduce" [ color="#d78100" ];
  "class clojure.lang.PersistentVector" -> "interface clojure.lang.IKVReduce" [ color="#d78100" ];
  "class clojure.lang.ProxyHandler" [ label="ProxyHandler" color="#0061d7" shape="oval"];
  "class clojure.lang.ProxyHandler" -> "interface java.lang.reflect.InvocationHandler" [ color="#0061d7" ];
  "interface java.util.RandomAccess" [ label="j.u.RandomAccess" color="#d7009e" shape="parallelogram"];
  "class clojure.lang.Range" [ label="Range\n[MWTHZ]" color="#00d0d7" shape="oval"];
  "class clojure.lang.Range" -> "class clojure.lang.ASeq" [ color="#00d0d7" ];
  "class clojure.lang.Range" -> "interface clojure.lang.IChunkedSeq" [ color="#00d0d7" ];
  "class clojure.lang.Range" -> "interface clojure.lang.IReduce" [ color="#00d0d7" ];
  "class clojure.lang.Ratio" [ label="Ratio\nratio?\n[Z=]" color="#d78100" shape="oval"];
  "class clojure.lang.ReaderConditional" [ label="ReaderConditional\nreader-conditional?" color="#b300d7" shape="oval"];
  "class clojure.lang.ReaderConditional" -> "interface clojure.lang.ILookup" [ color="#b300d7" ];
  "class clojure.lang.RecordIterator" [ label="RecordIterator" color="#76d700" shape="oval"];
  "class clojure.lang.RecordIterator" -> "interface java.util.Iterator" [ color="#76d700" ];
  "class clojure.lang.Reduced" [ label="Reduced" color="#d70000" shape="oval"];
  "class clojure.lang.Reduced" -> "interface clojure.lang.IDeref" [ color="#d70000" ];
  "class clojure.lang.Ref" [ label="Ref\n[M=]" color="#d78100" shape="oval"];
  "class clojure.lang.Ref" -> "class clojure.lang.ARef" [ color="#d78100" ];
  "class clojure.lang.Ref" -> "interface clojure.lang.IFn" [ color="#d78100" ];
  "class clojure.lang.Ref" -> "interface clojure.lang.IRef" [ color="#d78100" ];
  "interface clojure.reflect.Reflector" [ label="clojure.reflect.Reflector" color="#b300d7" shape="octagon"];
  "class clojure.lang.Repeat" [ label="Repeat\n[MWTHZ]" color="#76d700" shape="oval"];
  "class clojure.lang.Repeat" -> "class clojure.lang.ASeq" [ color="#76d700" ];
  "class clojure.lang.Repeat" -> "interface clojure.lang.IReduce" [ color="#76d700" ];
  "class clojure.lang.RestFn" [ label="RestFn\n[MWZ]" color="#0061d7" shape="oval"];
  "class clojure.lang.RestFn" -> "class clojure.lang.AFunction" [ color="#0061d7" ];
  "interface java.lang.Runnable" [ label="j.l.Runnable" color="#00d0d7" shape="parallelogram"];
  "class clojure.lang.SeqEnumeration" [ label="SeqEnumeration" color="#0061d7" shape="oval"];
  "class clojure.lang.SeqEnumeration" -> "interface java.util.Enumeration" [ color="#0061d7" ];
  "class clojure.lang.SeqIterator" [ label="SeqIterator" color="#76d700" shape="oval"];
  "class clojure.lang.SeqIterator" -> "interface java.util.Iterator" [ color="#76d700" ];
  "interface clojure.lang.Seqable" [ label="Seqable" color="#d78100" shape="octagon"];
  "interface clojure.lang.Sequential" [ label="Sequential\nsequential?" color="#d78100" shape="octagon"];
  "interface java.util.Set" [ label="j.u.Set\n[T]" color="#00d0d7" shape="parallelogram"];
  "interface java.util.Set" -> "interface java.util.Collection" [ color="#00d0d7" ];
  "interface clojure.lang.Settable" [ label="Settable" color="#0061d7" shape="octagon"];
  "interface clojure.lang.Sorted" [ label="Sorted\nsorted?" color="#5a00d7" shape="octagon"];
  "class clojure.lang.StringSeq" [ label="StringSeq\n[MWT1HZ]" color="#d7009e" shape="oval"];
  "class clojure.lang.StringSeq" -> "class clojure.lang.ASeq" [ color="#d7009e" ];
  "class clojure.lang.StringSeq" -> "interface clojure.lang.IndexedSeq" [ color="#d7009e" ];
  "class clojure.lang.Symbol" [ label="Symbol\nsymbol?\n[MWHZN=]" color="#0061d7" shape="oval"];
  "class clojure.lang.Symbol" -> "class clojure.lang.AFn" [ color="#0061d7" ];
  "class clojure.lang.TaggedLiteral" [ label="TaggedLiteral\ntagged-literal?" color="#00d764" shape="oval"];
  "class clojure.lang.TaggedLiteral" -> "interface clojure.lang.ILookup" [ color="#00d764" ];
  "class clojure.lang.TransactionalHashMap" [ label="TransactionalHashMap" color="#d7009e" shape="oval"];
  "class clojure.lang.TransactionalHashMap" -> "interface java.util.concurrent.ConcurrentMap" [ color="#d7009e" ];
  "class clojure.lang.TransformerIterator" [ label="TransformerIterator" color="#00d764" shape="oval"];
  "class clojure.lang.TransformerIterator" -> "interface java.util.Iterator" [ color="#00d764" ];
  "class clojure.lang.Var" [ label="Var\nvar?\n[MZ]" color="#00d0d7" shape="oval"];
  "class clojure.lang.Var" -> "class clojure.lang.ARef" [ color="#00d0d7" ];
  "class clojure.lang.Var" -> "interface clojure.lang.IFn" [ color="#00d0d7" ];
  "class clojure.lang.Var" -> "interface clojure.lang.IRef" [ color="#00d0d7" ];
  "class clojure.lang.Var" -> "interface clojure.lang.Settable" [ color="#00d0d7" ];
  "class clojure.core.Vec" [ label="c.c.Vec\n[DMWT1HR=]" color="#d78100" shape="oval"];
  "class clojure.core.Vec" -> "interface clojure.lang.Associative" [ color="#d78100" ];
  "class clojure.core.Vec" -> "interface java.util.Collection" [ color="#d78100" ];
  "class clojure.core.Vec" -> "interface clojure.lang.ILookup" [ color="#d78100" ];
  "class clojure.core.Vec" -> "interface clojure.lang.IPersistentCollection" [ color="#d78100" ];
  "class clojure.core.Vec" -> "interface clojure.core.IVecImpl" [ color="#d78100" ];
  "class clojure.core.Vec" -> "interface clojure.lang.IFn" [ color="#d78100" ];
  "class clojure.core.Vec" -> "interface clojure.lang.Sequential" [ color="#d78100" ];
  "class clojure.core.Vec" -> "interface clojure.lang.IPersistentVector" [ color="#d78100" ];
  "class clojure.core.Vec" -> "interface clojure.lang.Seqable" [ color="#d78100" ];
  "class clojure.core.Vec" -> "interface clojure.lang.IPersistentStack" [ color="#d78100" ];
  "class clojure.core.Vec" -> "interface java.util.List" [ color="#d78100" ];
  "class clojure.core.Vec" -> "interface clojure.lang.Indexed" [ color="#d78100" ];
  "class clojure.core.VecNode" [ label="c.c.VecNode\n[D]" color="#d7009e" shape="oval"];
  "class clojure.core.VecSeq" [ label="c.c.VecSeq\n[D]" color="#00d764" shape="oval"];
  "class clojure.core.VecSeq" -> "interface clojure.lang.ISeq" [ color="#00d764" ];
  "class clojure.core.VecSeq" -> "interface clojure.lang.IChunkedSeq" [ color="#00d764" ];
  "class clojure.core.VecSeq" -> "interface clojure.core.protocols.InternalReduce" [ color="#00d764" ];
  "class clojure.core.VecSeq" -> "interface clojure.lang.Seqable" [ color="#00d764" ];
  "class clojure.lang.Volatile" [ label="Volatile\nvolatile?" color="#00d0d7" shape="oval"];
  "class clojure.lang.Volatile" -> "interface clojure.lang.IDeref" [ color="#00d0d7" ];
  "interface clojure.lang.WarnBoxedMath" [ label="WarnBoxedMath" color="#00d0d7" shape="octagon"];
  "interface clojure.lang.WarnBoxedMath" -> "interface java.lang.annotation.Annotation" [ color="#00d0d7" ];
  "class clojure.core$future_call$reify__8454" [ label="(future)\n[MW]" color="#d70000" shape="oval"];
  "class clojure.core$future_call$reify__8454" -> "interface clojure.lang.IPending" [ color="#d70000" ];
  "class clojure.core$future_call$reify__8454" -> "interface clojure.lang.IBlockingDeref" [ color="#d70000" ];
  "class clojure.core$future_call$reify__8454" -> "interface java.util.concurrent.Future" [ color="#d70000" ];
  "class clojure.core$future_call$reify__8454" -> "interface clojure.lang.IDeref" [ color="#d70000" ];
}
