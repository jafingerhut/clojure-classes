digraph {
  rankdir=LR;
  dpi=55;
  nodesep=0.10;
  ranksep=1.2;
  mclimit=2500.0;
  node[ fontname=Helvetica shape=box ];
  splines=ortho;

  subgraph cluster_legend {
    label="Legend"
    fontname="Helvetica Bold"
    fontsize=19
    bgcolor="#dddddd"
    "Clojure Interface" [ shape=octagon fillcolor="#ffffff" style=filled ];
    "Java Interface" [ shape=diamond fillcolor="#ffffff" style=filled ];
    "Clojure class" [ shape=oval fillcolor="#ffffff" style=filled ];
    
    badges [
      shape=record
      style=filled
      fillcolor="#ffffff"
      label="{{M|W|T|1|H|Z|R|N|=}|{IMeta|IObj|Iterable|Counted|IHashEq|Serializable|Reversible|Named|Comparable}}"
    ]
  }
  "class clojure.lang.AFn" [ label="AFn" color="#00d0d7" shape="oval"];
  "class clojure.lang.AFn" -> "interface clojure.lang.IFn" [ color="#00d0d7" ];
  "class clojure.lang.AFunction" [ label="AFunction\n[MWZ]" color="#d7009e" shape="oval"];
  "class clojure.lang.AFunction" -> "class clojure.lang.AFn" [ color="#d7009e" ];
  "class clojure.lang.AFunction" -> "interface java.util.Comparator" [ color="#d7009e" ];
  "class clojure.lang.AFunction" -> "interface clojure.lang.Fn" [ color="#d7009e" ];
  "class clojure.lang.AMapEntry" [ label="AMapEntry\n[T1HZR=]" color="#00d764" shape="oval"];
  "class clojure.lang.AMapEntry" -> "class clojure.lang.APersistentVector" [ color="#00d764" ];
  "class clojure.lang.AMapEntry" -> "interface clojure.lang.IMapEntry" [ color="#00d764" ];
  "class clojure.lang.APersistentMap" [ label="APersistentMap\n[T1HZ]" color="#0061d7" shape="oval"];
  "class clojure.lang.APersistentMap" -> "class clojure.lang.AFn" [ color="#0061d7" ];
  "class clojure.lang.APersistentMap" -> "interface clojure.lang.IPersistentMap" [ color="#0061d7" ];
  "class clojure.lang.APersistentMap" -> "interface java.util.Map" [ color="#0061d7" ];
  "class clojure.lang.APersistentMap" -> "interface clojure.lang.MapEquivalence" [ color="#0061d7" ];
  "class clojure.lang.APersistentSet" [ label="APersistentSet\n[T1HZ]" color="#d70000" shape="oval"];
  "class clojure.lang.APersistentSet" -> "class clojure.lang.AFn" [ color="#d70000" ];
  "class clojure.lang.APersistentSet" -> "interface clojure.lang.IPersistentSet" [ color="#d70000" ];
  "class clojure.lang.APersistentSet" -> "interface java.util.Collection" [ color="#d70000" ];
  "class clojure.lang.APersistentSet" -> "interface java.util.Set" [ color="#d70000" ];
  "class clojure.lang.APersistentVector" [ label="APersistentVector\n[T1HZR=]" color="#00d764" shape="oval"];
  "class clojure.lang.APersistentVector" -> "class clojure.lang.AFn" [ color="#00d764" ];
  "class clojure.lang.APersistentVector" -> "interface clojure.lang.IPersistentVector" [ color="#00d764" ];
  "class clojure.lang.APersistentVector" -> "interface java.util.List" [ color="#00d764" ];
  "class clojure.lang.APersistentVector" -> "interface java.util.RandomAccess" [ color="#00d764" ];
  "class clojure.lang.ARef" [ label="ARef\n[M]" color="#d70000" shape="oval"];
  "class clojure.lang.ARef" -> "class clojure.lang.AReference" [ color="#d70000" ];
  "class clojure.lang.ARef" -> "interface clojure.lang.IRef" [ color="#d70000" ];
  "class clojure.lang.AReference" [ label="AReference\n[M]" color="#d78100" shape="oval"];
  "class clojure.lang.AReference" -> "interface clojure.lang.IReference" [ color="#d78100" ];
  "class clojure.lang.ASeq" [ label="ASeq\n[MWTHZ]" color="#d70000" shape="oval"];
  "class clojure.lang.ASeq" -> "class clojure.lang.Obj" [ color="#d70000" ];
  "class clojure.lang.ASeq" -> "interface clojure.lang.ISeq" [ color="#d70000" ];
  "class clojure.lang.ASeq" -> "interface clojure.lang.Sequential" [ color="#d70000" ];
  "class clojure.lang.ASeq" -> "interface java.util.List" [ color="#d70000" ];
  "class clojure.lang.ATransientMap" [ label="ATransientMap\n[1]" color="#d78100" shape="oval"];
  "class clojure.lang.ATransientMap" -> "class clojure.lang.AFn" [ color="#d78100" ];
  "class clojure.lang.ATransientMap" -> "interface clojure.lang.ITransientMap" [ color="#d78100" ];
  "class clojure.lang.ATransientMap" -> "interface clojure.lang.ITransientAssociative2" [ color="#d78100" ];
  "class clojure.lang.ATransientSet" [ label="ATransientSet\n[1]" color="#5a00d7" shape="oval"];
  "class clojure.lang.ATransientSet" -> "class clojure.lang.AFn" [ color="#5a00d7" ];
  "class clojure.lang.ATransientSet" -> "interface clojure.lang.ITransientSet" [ color="#5a00d7" ];
  "class clojure.lang.Agent" [ label="Agent\n[M]" color="#d78100" shape="oval"];
  "class clojure.lang.Agent" -> "class clojure.lang.ARef" [ color="#d78100" ];
  "interface java.lang.annotation.Annotation" [ label="Annotation" color="#76d700" shape="diamond"];
  "class clojure.lang.ArrayChunk" [ label="ArrayChunk\n[1Z]" color="#76d700" shape="oval"];
  "class clojure.lang.ArrayChunk" -> "interface clojure.lang.IChunk" [ color="#76d700" ];
  "class clojure.lang.ArrayIter" [ label="ArrayIter" color="#00d0d7" shape="oval"];
  "class clojure.lang.ArrayIter" -> "interface java.util.Iterator" [ color="#00d0d7" ];
  "class clojure.lang.ArraySeq" [ label="ArraySeq\n[MWT1HZ]" color="#76d700" shape="oval"];
  "class clojure.lang.ArraySeq" -> "class clojure.lang.ASeq" [ color="#76d700" ];
  "class clojure.lang.ArraySeq" -> "interface clojure.lang.IndexedSeq" [ color="#76d700" ];
  "class clojure.lang.ArraySeq" -> "interface clojure.lang.IReduce" [ color="#76d700" ];
  "interface clojure.lang.Associative" [ label="Associative\nassociative?" color="#d70000" shape="octagon"];
  "interface clojure.lang.Associative" -> "interface clojure.lang.IPersistentCollection" [ color="#d70000" ];
  "interface clojure.lang.Associative" -> "interface clojure.lang.ILookup" [ color="#d70000" ];
  "class clojure.lang.Atom" [ label="Atom\n[M]" color="#00d764" shape="oval"];
  "class clojure.lang.Atom" -> "class clojure.lang.ARef" [ color="#00d764" ];
  "class clojure.lang.Atom" -> "interface clojure.lang.IAtom2" [ color="#00d764" ];
  "class clojure.lang.BigInt" [ label="BigInt\n[HZ]" color="#76d700" shape="oval"];
  "interface java.util.concurrent.Callable" [ label="Callable" color="#00d0d7" shape="diamond"];
  "class clojure.lang.ChunkBuffer" [ label="ChunkBuffer\n[1]" color="#d7009e" shape="oval"];
  "class clojure.lang.ChunkedCons" [ label="ChunkedCons\n[MWTHZ]" color="#76d700" shape="oval"];
  "class clojure.lang.ChunkedCons" -> "class clojure.lang.ASeq" [ color="#76d700" ];
  "class clojure.lang.ChunkedCons" -> "interface clojure.lang.IChunkedSeq" [ color="#76d700" ];
  "interface java.util.Collection" [ label="Collection\n[T]" color="#5a00d7" shape="diamond"];
  "interface java.util.Comparator" [ label="Comparator" color="#b300d7" shape="diamond"];
  "interface java.util.concurrent.ConcurrentMap" [ label="ConcurrentMap" color="#d78100" shape="diamond"];
  "interface java.util.concurrent.ConcurrentMap" -> "interface java.util.Map" [ color="#d78100" ];
  "class clojure.lang.Cons" [ label="Cons\n[MWTHZ]" color="#5a00d7" shape="oval"];
  "class clojure.lang.Cons" -> "class clojure.lang.ASeq" [ color="#5a00d7" ];
  "class clojure.lang.Cycle" [ label="Cycle\n[MWTHZ]" color="#d70000" shape="oval"];
  "class clojure.lang.Cycle" -> "class clojure.lang.ASeq" [ color="#d70000" ];
  "class clojure.lang.Cycle" -> "interface clojure.lang.IReduce" [ color="#d70000" ];
  "class clojure.lang.Cycle" -> "interface clojure.lang.IPending" [ color="#d70000" ];
  "class clojure.lang.Delay" [ label="Delay\ndelay?" color="#0061d7" shape="oval"];
  "class clojure.lang.Delay" -> "interface clojure.lang.IDeref" [ color="#0061d7" ];
  "class clojure.lang.Delay" -> "interface clojure.lang.IPending" [ color="#0061d7" ];
  "interface java.util.Map$Entry" [ label="Entry" color="#d7009e" shape="diamond"];
  "interface java.util.Enumeration" [ label="Enumeration" color="#d70000" shape="diamond"];
  "class clojure.lang.EnumerationSeq" [ label="EnumerationSeq\n[MWTHZ]" color="#00d764" shape="oval"];
  "class clojure.lang.EnumerationSeq" -> "class clojure.lang.ASeq" [ color="#00d764" ];
  "class clojure.lang.ExceptionInfo" [ label="ExceptionInfo\n[Z]" color="#0061d7" shape="oval"];
  "class clojure.lang.ExceptionInfo" -> "interface clojure.lang.IExceptionInfo" [ color="#0061d7" ];
  "interface clojure.lang.Fn" [ label="Fn\nfn?" color="#d7009e" shape="octagon"];
  "class clojure.lang.FnLoaderThunk" [ label="FnLoaderThunk\n[MWZ]" color="#d70000" shape="oval"];
  "class clojure.lang.FnLoaderThunk" -> "class clojure.lang.RestFn" [ color="#d70000" ];
  "interface clojure.lang.IAtom" [ label="IAtom" color="#76d700" shape="octagon"];
  "interface clojure.lang.IAtom2" [ label="IAtom2" color="#00d0d7" shape="octagon"];
  "interface clojure.lang.IAtom2" -> "interface clojure.lang.IAtom" [ color="#00d0d7" ];
  "interface clojure.lang.IChunk" [ label="IChunk\n[1]" color="#00d764" shape="octagon"];
  "interface clojure.lang.IChunk" -> "interface clojure.lang.Indexed" [ color="#00d764" ];
  "interface clojure.lang.IChunkedSeq" [ label="IChunkedSeq\nchunked-seq?" color="#5a00d7" shape="octagon"];
  "interface clojure.lang.IChunkedSeq" -> "interface clojure.lang.ISeq" [ color="#5a00d7" ];
  "interface clojure.lang.IChunkedSeq" -> "interface clojure.lang.Sequential" [ color="#5a00d7" ];
  "interface clojure.lang.IDeref" [ label="IDeref" color="#b300d7" shape="octagon"];
  "interface clojure.lang.IEditableCollection" [ label="IEditableCollection" color="#d70000" shape="octagon"];
  "interface clojure.lang.IExceptionInfo" [ label="IExceptionInfo" color="#d78100" shape="octagon"];
  "interface clojure.lang.IFn" [ label="IFn\nifn?" color="#00d764" shape="octagon"];
  "interface clojure.lang.IFn" -> "interface java.util.concurrent.Callable" [ color="#00d764" ];
  "interface clojure.lang.IFn" -> "interface java.lang.Runnable" [ color="#00d764" ];
  "interface clojure.lang.IKVReduce" [ label="IKVReduce" color="#76d700" shape="octagon"];
  "interface clojure.lang.ILookup" [ label="ILookup" color="#d7009e" shape="octagon"];
  "interface clojure.lang.ILookupSite" [ label="ILookupSite" color="#d78100" shape="octagon"];
  "interface clojure.lang.ILookupThunk" [ label="ILookupThunk" color="#0061d7" shape="octagon"];
  "interface clojure.lang.IMapEntry" [ label="IMapEntry" color="#00d764" shape="octagon"];
  "interface clojure.lang.IMapEntry" -> "interface java.util.Map$Entry" [ color="#00d764" ];
  "interface clojure.lang.IMapIterable" [ label="IMapIterable" color="#d70000" shape="octagon"];
  "interface clojure.lang.IPending" [ label="IPending" color="#76d700" shape="octagon"];
  "interface clojure.lang.IPersistentCollection" [ label="IPersistentCollection\ncoll?" color="#b300d7" shape="octagon"];
  "interface clojure.lang.IPersistentCollection" -> "interface clojure.lang.Seqable" [ color="#b300d7" ];
  "interface clojure.lang.IPersistentList" [ label="IPersistentList\nlist?" color="#d78100" shape="octagon"];
  "interface clojure.lang.IPersistentList" -> "interface clojure.lang.Sequential" [ color="#d78100" ];
  "interface clojure.lang.IPersistentList" -> "interface clojure.lang.IPersistentStack" [ color="#d78100" ];
  "interface clojure.lang.IPersistentMap" [ label="IPersistentMap\nmap?\n[T1]" color="#00d764" shape="octagon"];
  "interface clojure.lang.IPersistentMap" -> "interface clojure.lang.Associative" [ color="#00d764" ];
  "interface clojure.lang.IPersistentSet" [ label="IPersistentSet\nset?\n[1]" color="#5a00d7" shape="octagon"];
  "interface clojure.lang.IPersistentSet" -> "interface clojure.lang.IPersistentCollection" [ color="#5a00d7" ];
  "interface clojure.lang.IPersistentStack" [ label="IPersistentStack" color="#d70000" shape="octagon"];
  "interface clojure.lang.IPersistentStack" -> "interface clojure.lang.IPersistentCollection" [ color="#d70000" ];
  "interface clojure.lang.IPersistentVector" [ label="IPersistentVector\nvector?\n[1R]" color="#0061d7" shape="octagon"];
  "interface clojure.lang.IPersistentVector" -> "interface clojure.lang.Associative" [ color="#0061d7" ];
  "interface clojure.lang.IPersistentVector" -> "interface clojure.lang.Sequential" [ color="#0061d7" ];
  "interface clojure.lang.IPersistentVector" -> "interface clojure.lang.IPersistentStack" [ color="#0061d7" ];
  "interface clojure.lang.IPersistentVector" -> "interface clojure.lang.Indexed" [ color="#0061d7" ];
  "interface clojure.lang.IReduce" [ label="IReduce" color="#00d0d7" shape="octagon"];
  "interface clojure.lang.IReduce" -> "interface clojure.lang.IReduceInit" [ color="#00d0d7" ];
  "interface clojure.lang.IReduceInit" [ label="IReduceInit" color="#76d700" shape="octagon"];
  "interface clojure.lang.IRef" [ label="IRef" color="#d7009e" shape="octagon"];
  "interface clojure.lang.IRef" -> "interface clojure.lang.IDeref" [ color="#d7009e" ];
  "interface clojure.lang.IReference" [ label="IReference\n[M]" color="#00d764" shape="octagon"];
  "interface clojure.lang.ISeq" [ label="ISeq\nseq?" color="#d78100" shape="octagon"];
  "interface clojure.lang.ISeq" -> "interface clojure.lang.IPersistentCollection" [ color="#d78100" ];
  "interface clojure.lang.ITransientAssociative" [ label="ITransientAssociative" color="#d70000" shape="octagon"];
  "interface clojure.lang.ITransientAssociative" -> "interface clojure.lang.ITransientCollection" [ color="#d70000" ];
  "interface clojure.lang.ITransientAssociative" -> "interface clojure.lang.ILookup" [ color="#d70000" ];
  "interface clojure.lang.ITransientAssociative2" [ label="ITransientAssociative2" color="#5a00d7" shape="octagon"];
  "interface clojure.lang.ITransientAssociative2" -> "interface clojure.lang.ITransientAssociative" [ color="#5a00d7" ];
  "interface clojure.lang.ITransientCollection" [ label="ITransientCollection" color="#d70000" shape="octagon"];
  "interface clojure.lang.ITransientMap" [ label="ITransientMap\n[1]" color="#76d700" shape="octagon"];
  "interface clojure.lang.ITransientMap" -> "interface clojure.lang.ITransientAssociative" [ color="#76d700" ];
  "interface clojure.lang.ITransientSet" [ label="ITransientSet\n[1]" color="#00d0d7" shape="octagon"];
  "interface clojure.lang.ITransientSet" -> "interface clojure.lang.ITransientCollection" [ color="#00d0d7" ];
  "interface clojure.lang.ITransientVector" [ label="ITransientVector\n[1]" color="#00d764" shape="octagon"];
  "interface clojure.lang.ITransientVector" -> "interface clojure.lang.ITransientAssociative" [ color="#00d764" ];
  "interface clojure.lang.ITransientVector" -> "interface clojure.lang.Indexed" [ color="#00d764" ];
  "interface clojure.lang.Indexed" [ label="Indexed\nindexed?\n[1]" color="#00d764" shape="octagon"];
  "interface clojure.lang.IndexedSeq" [ label="IndexedSeq\n[1]" color="#b300d7" shape="octagon"];
  "interface clojure.lang.IndexedSeq" -> "interface clojure.lang.ISeq" [ color="#b300d7" ];
  "interface clojure.lang.IndexedSeq" -> "interface clojure.lang.Sequential" [ color="#b300d7" ];
  "interface java.lang.reflect.InvocationHandler" [ label="InvocationHandler" color="#d7009e" shape="diamond"];
  "class clojure.lang.Iterate" [ label="Iterate\n[MWTHZ]" color="#d7009e" shape="oval"];
  "class clojure.lang.Iterate" -> "class clojure.lang.ASeq" [ color="#d7009e" ];
  "class clojure.lang.Iterate" -> "interface clojure.lang.IReduce" [ color="#d7009e" ];
  "class clojure.lang.Iterate" -> "interface clojure.lang.IPending" [ color="#d7009e" ];
  "interface java.util.Iterator" [ label="Iterator" color="#0061d7" shape="diamond"];
  "class clojure.lang.IteratorSeq" [ label="IteratorSeq\n[MWTHZ]" color="#00d0d7" shape="oval"];
  "class clojure.lang.IteratorSeq" -> "class clojure.lang.ASeq" [ color="#00d0d7" ];
  "class clojure.lang.Keyword" [ label="Keyword\nkeyword?\n[HZN=]" color="#5a00d7" shape="oval"];
  "class clojure.lang.Keyword" -> "interface clojure.lang.IFn" [ color="#5a00d7" ];
  "class clojure.lang.KeywordLookupSite" [ label="KeywordLookupSite" color="#b300d7" shape="oval"];
  "class clojure.lang.KeywordLookupSite" -> "interface clojure.lang.ILookupSite" [ color="#b300d7" ];
  "class clojure.lang.KeywordLookupSite" -> "interface clojure.lang.ILookupThunk" [ color="#b300d7" ];
  "class clojure.lang.LazySeq" [ label="LazySeq\n[MWTHZ]" color="#d78100" shape="oval"];
  "class clojure.lang.LazySeq" -> "class clojure.lang.Obj" [ color="#d78100" ];
  "class clojure.lang.LazySeq" -> "interface clojure.lang.ISeq" [ color="#d78100" ];
  "class clojure.lang.LazySeq" -> "interface clojure.lang.Sequential" [ color="#d78100" ];
  "class clojure.lang.LazySeq" -> "interface java.util.List" [ color="#d78100" ];
  "class clojure.lang.LazySeq" -> "interface clojure.lang.IPending" [ color="#d78100" ];
  "interface java.util.List" [ label="List\n[T]" color="#76d700" shape="diamond"];
  "interface java.util.List" -> "interface java.util.Collection" [ color="#76d700" ];
  "class clojure.lang.LongRange" [ label="LongRange\n[MWT1HZ]" color="#d7009e" shape="oval"];
  "class clojure.lang.LongRange" -> "class clojure.lang.ASeq" [ color="#d7009e" ];
  "class clojure.lang.LongRange" -> "interface clojure.lang.IChunkedSeq" [ color="#d7009e" ];
  "class clojure.lang.LongRange" -> "interface clojure.lang.IReduce" [ color="#d7009e" ];
  "interface java.util.Map" [ label="Map" color="#0061d7" shape="diamond"];
  "class clojure.lang.MapEntry" [ label="MapEntry\n[T1HZR=]" color="#00d0d7" shape="oval"];
  "class clojure.lang.MapEntry" -> "class clojure.lang.AMapEntry" [ color="#00d0d7" ];
  "interface clojure.lang.MapEquivalence" [ label="MapEquivalence" color="#d70000" shape="octagon"];
  "class clojure.lang.MultiFn" [ label="MultiFn" color="#5a00d7" shape="oval"];
  "class clojure.lang.MultiFn" -> "class clojure.lang.AFn" [ color="#5a00d7" ];
  "class clojure.lang.Namespace" [ label="Namespace\n[MZ]" color="#76d700" shape="oval"];
  "class clojure.lang.Namespace" -> "class clojure.lang.AReference" [ color="#76d700" ];
  "class clojure.lang.Obj" [ label="Obj\n[MWZ]" color="#d78100" shape="oval"];
  "class clojure.lang.PersistentArrayMap" [ label="PersistentArrayMap\n[MWT1HZ]" color="#d78100" shape="oval"];
  "class clojure.lang.PersistentArrayMap" -> "class clojure.lang.APersistentMap" [ color="#d78100" ];
  "class clojure.lang.PersistentArrayMap" -> "interface clojure.lang.IEditableCollection" [ color="#d78100" ];
  "class clojure.lang.PersistentArrayMap" -> "interface clojure.lang.IMapIterable" [ color="#d78100" ];
  "class clojure.lang.PersistentArrayMap" -> "interface clojure.lang.IKVReduce" [ color="#d78100" ];
  "class clojure.lang.PersistentHashMap" [ label="PersistentHashMap\n[MWT1HZ]" color="#d78100" shape="oval"];
  "class clojure.lang.PersistentHashMap" -> "class clojure.lang.APersistentMap" [ color="#d78100" ];
  "class clojure.lang.PersistentHashMap" -> "interface clojure.lang.IEditableCollection" [ color="#d78100" ];
  "class clojure.lang.PersistentHashMap" -> "interface clojure.lang.IMapIterable" [ color="#d78100" ];
  "class clojure.lang.PersistentHashMap" -> "interface clojure.lang.IKVReduce" [ color="#d78100" ];
  "class clojure.lang.PersistentHashSet" [ label="PersistentHashSet\n[MWT1HZ]" color="#5a00d7" shape="oval"];
  "class clojure.lang.PersistentHashSet" -> "class clojure.lang.APersistentSet" [ color="#5a00d7" ];
  "class clojure.lang.PersistentHashSet" -> "interface clojure.lang.IEditableCollection" [ color="#5a00d7" ];
  "class clojure.lang.PersistentList" [ label="PersistentList\n[MWT1HZ]" color="#76d700" shape="oval"];
  "class clojure.lang.PersistentList" -> "class clojure.lang.ASeq" [ color="#76d700" ];
  "class clojure.lang.PersistentList" -> "interface clojure.lang.IPersistentList" [ color="#76d700" ];
  "class clojure.lang.PersistentList" -> "interface clojure.lang.IReduce" [ color="#76d700" ];
  "class clojure.lang.PersistentList" -> "interface java.util.List" [ color="#76d700" ];
  "class clojure.lang.PersistentQueue" [ label="PersistentQueue\n[MWT1HZ]" color="#0061d7" shape="oval"];
  "class clojure.lang.PersistentQueue" -> "class clojure.lang.Obj" [ color="#0061d7" ];
  "class clojure.lang.PersistentQueue" -> "interface clojure.lang.IPersistentList" [ color="#0061d7" ];
  "class clojure.lang.PersistentQueue" -> "interface java.util.Collection" [ color="#0061d7" ];
  "class clojure.lang.PersistentStructMap" [ label="PersistentStructMap\n[MWT1HZ]" color="#b300d7" shape="oval"];
  "class clojure.lang.PersistentStructMap" -> "class clojure.lang.APersistentMap" [ color="#b300d7" ];
  "class clojure.lang.PersistentTreeMap" [ label="PersistentTreeMap\n[MWT1HZR]" color="#00d0d7" shape="oval"];
  "class clojure.lang.PersistentTreeMap" -> "class clojure.lang.APersistentMap" [ color="#00d0d7" ];
  "class clojure.lang.PersistentTreeMap" -> "interface clojure.lang.Sorted" [ color="#00d0d7" ];
  "class clojure.lang.PersistentTreeMap" -> "interface clojure.lang.IKVReduce" [ color="#00d0d7" ];
  "class clojure.lang.PersistentTreeSet" [ label="PersistentTreeSet\n[MWT1HZR]" color="#76d700" shape="oval"];
  "class clojure.lang.PersistentTreeSet" -> "class clojure.lang.APersistentSet" [ color="#76d700" ];
  "class clojure.lang.PersistentTreeSet" -> "interface clojure.lang.Sorted" [ color="#76d700" ];
  "class clojure.lang.PersistentVector" [ label="PersistentVector\n[MWT1HZR=]" color="#0061d7" shape="oval"];
  "class clojure.lang.PersistentVector" -> "class clojure.lang.APersistentVector" [ color="#0061d7" ];
  "class clojure.lang.PersistentVector" -> "interface clojure.lang.IEditableCollection" [ color="#0061d7" ];
  "class clojure.lang.PersistentVector" -> "interface clojure.lang.IReduce" [ color="#0061d7" ];
  "class clojure.lang.PersistentVector" -> "interface clojure.lang.IKVReduce" [ color="#0061d7" ];
  "class clojure.lang.ProxyHandler" [ label="ProxyHandler" color="#d7009e" shape="oval"];
  "class clojure.lang.ProxyHandler" -> "interface java.lang.reflect.InvocationHandler" [ color="#d7009e" ];
  "interface java.util.RandomAccess" [ label="RandomAccess" color="#00d0d7" shape="diamond"];
  "class clojure.lang.Range" [ label="Range\n[MWTHZ]" color="#00d0d7" shape="oval"];
  "class clojure.lang.Range" -> "class clojure.lang.ASeq" [ color="#00d0d7" ];
  "class clojure.lang.Range" -> "interface clojure.lang.IChunkedSeq" [ color="#00d0d7" ];
  "class clojure.lang.Range" -> "interface clojure.lang.IReduce" [ color="#00d0d7" ];
  "class clojure.lang.Ratio" [ label="Ratio\nratio?\n[Z=]" color="#5a00d7" shape="oval"];
  "class clojure.lang.ReaderConditional" [ label="ReaderConditional\nreader-conditional?" color="#b300d7" shape="oval"];
  "class clojure.lang.ReaderConditional" -> "interface clojure.lang.ILookup" [ color="#b300d7" ];
  "class clojure.lang.RecordIterator" [ label="RecordIterator" color="#0061d7" shape="oval"];
  "class clojure.lang.RecordIterator" -> "interface java.util.Iterator" [ color="#0061d7" ];
  "class clojure.lang.Reduced" [ label="Reduced" color="#0061d7" shape="oval"];
  "class clojure.lang.Reduced" -> "interface clojure.lang.IDeref" [ color="#0061d7" ];
  "class clojure.lang.Ref" [ label="Ref\n[M=]" color="#00d0d7" shape="oval"];
  "class clojure.lang.Ref" -> "class clojure.lang.ARef" [ color="#00d0d7" ];
  "class clojure.lang.Ref" -> "interface clojure.lang.IFn" [ color="#00d0d7" ];
  "class clojure.lang.Ref" -> "interface clojure.lang.IRef" [ color="#00d0d7" ];
  "class clojure.lang.Repeat" [ label="Repeat\n[MWTHZ]" color="#d78100" shape="oval"];
  "class clojure.lang.Repeat" -> "class clojure.lang.ASeq" [ color="#d78100" ];
  "class clojure.lang.Repeat" -> "interface clojure.lang.IReduce" [ color="#d78100" ];
  "class clojure.lang.RestFn" [ label="RestFn\n[MWZ]" color="#76d700" shape="oval"];
  "class clojure.lang.RestFn" -> "class clojure.lang.AFunction" [ color="#76d700" ];
  "interface java.lang.Runnable" [ label="Runnable" color="#5a00d7" shape="diamond"];
  "class clojure.lang.SeqEnumeration" [ label="SeqEnumeration" color="#00d0d7" shape="oval"];
  "class clojure.lang.SeqEnumeration" -> "interface java.util.Enumeration" [ color="#00d0d7" ];
  "class clojure.lang.SeqIterator" [ label="SeqIterator" color="#5a00d7" shape="oval"];
  "class clojure.lang.SeqIterator" -> "interface java.util.Iterator" [ color="#5a00d7" ];
  "interface clojure.lang.Seqable" [ label="Seqable" color="#d78100" shape="octagon"];
  "interface clojure.lang.Sequential" [ label="Sequential\nsequential?" color="#b300d7" shape="octagon"];
  "interface java.util.Set" [ label="Set\n[T]" color="#d70000" shape="diamond"];
  "interface java.util.Set" -> "interface java.util.Collection" [ color="#d70000" ];
  "interface clojure.lang.Settable" [ label="Settable" color="#d7009e" shape="octagon"];
  "interface clojure.lang.Sorted" [ label="Sorted\nsorted?" color="#00d764" shape="octagon"];
  "class clojure.lang.StringSeq" [ label="StringSeq\n[MWT1HZ]" color="#d7009e" shape="oval"];
  "class clojure.lang.StringSeq" -> "class clojure.lang.ASeq" [ color="#d7009e" ];
  "class clojure.lang.StringSeq" -> "interface clojure.lang.IndexedSeq" [ color="#d7009e" ];
  "class clojure.lang.Symbol" [ label="Symbol\nsymbol?\n[MWHZN=]" color="#d7009e" shape="oval"];
  "class clojure.lang.Symbol" -> "class clojure.lang.AFn" [ color="#d7009e" ];
  "class clojure.lang.TaggedLiteral" [ label="TaggedLiteral\ntagged-literal?" color="#b300d7" shape="oval"];
  "class clojure.lang.TaggedLiteral" -> "interface clojure.lang.ILookup" [ color="#b300d7" ];
  "class clojure.lang.TransactionalHashMap" [ label="TransactionalHashMap" color="#00d0d7" shape="oval"];
  "class clojure.lang.TransactionalHashMap" -> "interface java.util.concurrent.ConcurrentMap" [ color="#00d0d7" ];
  "class clojure.lang.TransformerIterator" [ label="TransformerIterator" color="#00d0d7" shape="oval"];
  "class clojure.lang.TransformerIterator" -> "interface java.util.Iterator" [ color="#00d0d7" ];
  "class clojure.lang.Var" [ label="Var\nvar?\n[MZ]" color="#d70000" shape="oval"];
  "class clojure.lang.Var" -> "class clojure.lang.ARef" [ color="#d70000" ];
  "class clojure.lang.Var" -> "interface clojure.lang.IFn" [ color="#d70000" ];
  "class clojure.lang.Var" -> "interface clojure.lang.IRef" [ color="#d70000" ];
  "class clojure.lang.Var" -> "interface clojure.lang.Settable" [ color="#d70000" ];
  "class clojure.lang.Volatile" [ label="Volatile\nvolatile?" color="#0061d7" shape="oval"];
  "class clojure.lang.Volatile" -> "interface clojure.lang.IDeref" [ color="#0061d7" ];
  "interface clojure.lang.WarnBoxedMath" [ label="WarnBoxedMath" color="#00d0d7" shape="octagon"];
  "interface clojure.lang.WarnBoxedMath" -> "interface java.lang.annotation.Annotation" [ color="#00d0d7" ];
}
